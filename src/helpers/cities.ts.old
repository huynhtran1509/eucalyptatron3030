var distance = require('jaro-winkler');
import { values } from 'ramda';

import "fs";
let fs = this.get("fs");
import 'path';
import cities from '../../data/cities';

export interface ICityData {
    zip: number;
    state: string;
    city?: string;
    lat: number;
    lng: number;
}

/*

   I know commented out code _is the worst_, but I wanted to
   illustrate what was done with the city data. Duplicate
   city names were removed, and only unique StateAbbr / CityName
   combinations were kept.

   After this, the data was moved into a *.ts file so that it
   could be imported directly vs. being parsed with JSON.


let cities: ICityData[];

// Wrapping this in a function so we don't muck up runtime speed
// on AWS. i.e. don't parse this large file unless we really need
// to do so.
function getCities() {
    if (cities) { return cities; }

    const citiesPath = path.join(__dirname, '..', '..', 'data', 'cities.json');

    // Data gathered and transformed into JSON from:
    // http://simplemaps.com/resources/us-cities-data
    cities = JSON.parse(fs.readFileSync(citiesPath, 'utf8'))


    // Remove duplicate city names. For our purposes, we just need
    // cities that are central to
    cities = values(cities.reduce((acc, city) => {
        const key = `${city.city}-${city.state}`;
        if (typeof acc[key] === 'undefined') { acc[key] = city; }
        return acc;
    }, {}));

    fs.writeFileSync(citiesPath, JSON.stringify(cities, null, 2));

    return cities;
}

*/

interface ICityInfo {
    cityScore: number;
    stateScore?: number;
    cityData: ICityData;
}

export function isPossibleCity(city: string): boolean {
    let i = 0, possibleCities = [], cityScore;
    const len = cities.length;

    for (; i < len; i++) {
        cityScore = distance(cities[i].city || '', city, { caseSensitive: false });

        if (cityScore > 0.95) {
            return true;
        }
    }

    return false;
}

/**
 * Given a city and a stateAbbr, get back a list of information
 * about that city. The state abbr is optional. If included, the
 * results should be more accurate.
 *
 * The final result is sorted where element "0" is the closest
 * match to the requested city state.
 *
 * If there were no matches, an empty list is returned.
 */
export function getCityInfo(city: string, stateAbbr?: string): ICityInfo[] {
    let i = 0, possibleCities = [], cityData, cityScore, stateScore;
    const len = cities.length;

    for (; i < len; i++) {
        cityData = cities[i];
        cityScore = distance(cityData.city || '', city, { caseSensitive: false });

        if (cityScore > 0.95) {
            let possibleCity: ICityInfo = { cityScore, cityData, stateScore: 0 };

            if (stateAbbr) {
                stateScore = distance(cityData.state, stateAbbr, { caseSensitive: false });
                if (stateScore === 1) {
                    possibleCity.stateScore = stateScore;
                }
            }

            possibleCities.push(possibleCity);
        }
    }

    return possibleCities.sort((a, b) => b.cityScore - a.cityScore)
                         .sort((a, b) => b.stateScore - a.stateScore);
}

/**
 * This function attempts to get city data from any given
 * utterance / raw string that the user provides. Returns
 * undefined if nothing was found.
 */
export function getCityDataFromUtterance(utterance: string) {
    const cleaned = utterance.trim().replace(/[^\w ]/gi, '');
    const words = cleaned.split(' ');

    // Get a list of possible cities from the utterance
    const single = words.filter(word => isPossibleCity(word));

    // Overlapping city names, e.g. "what is playing in new york?"
    // --> [ 'what is', 'is playing', 'playing in', 'in new', 'new york' ]
    // --> only clusters that are determined to be cities are kept
    const double: string[] = words.reduce((acc, curr, i) => {
        acc[i] = [curr];

        const prevIndex = i - 1;

        if (prevIndex >= 0) {
            acc[prevIndex] = acc[prevIndex].concat(curr);
        }

        return acc;
    }, []).filter(wordCluster => wordCluster.length === 2)
          .map(wordCluster => wordCluster.join(' '))
          .filter(word => isPossibleCity(word));

    // Note that we put preference on double as it's more specific.
    const possibleCities = [ ...double, ...single ];

    // Get a list of possible states that appear in the
    // cities (words of length 2, that appear after a possible
    // city name
    let possibleStates = possibleCities.reduce((acc, city) => {
        // split on the city. state should appear after the city name.
        const possibleState = (utterance.split(city)[1] || '')
            .replace(/[^\w ]/gi, '') // remove comma's, question marks, etc.
            .trim() // remove white space around the second half of the split.
            .split(' ')[0]; // finally, split on spaces & grab first word in second half.

        // If it is a word of length 2, we can consider it a possible state
        // beacuse it appeared after a possible city.
        if (possibleState.length == 2) {
            acc = acc.concat(possibleState);
        }

        return acc;
    }, []);

    // cycle through all possible combinations and store
    // them in thir results list
    let results: ICityInfo[] = [];

    possibleCities.forEach(city => {
        const cityInfo = getCityInfo(city);

        if (cityInfo.length > 0) {
            // We only care about the _best_ result that comes
            // back from the query
            results.push(cityInfo.sort((a, b) => b.cityScore - a.cityScore)[0]);
        }

        possibleStates.forEach(state => {
            const cityState = getCityInfo(city, state);

            if (cityState.length > 0) {
                // likewise, we only want the best result.
                results.push(cityState[0]);
            }
        });
    });

    // Now that we have the final results, sort them by them
    // by the state, then the city scores
    const sortedResults = results.sort((a, b) => {
        // let them fight
        if (a.stateScore && b.stateScore) { return b.stateScore - a.stateScore; }
        // give precidence of entries that have a state score
        if (b.stateScore && !a.stateScore) { return 1; }

        return 0;
    }).sort((a, b) => {
        return b.cityScore - a.cityScore;
    });

    // Pull out the first sorted result, else return undefined
    // if nothing was found
    return sortedResults.length > 0 ? sortedResults[0].cityData : void 0;
}

// console.log(getCityDataFromUtterance('new york'));
// console.time('foo');
// console.getCityDataFromUtterance('what is playing in washington dc?'));
// console.timeEnd('foo');
